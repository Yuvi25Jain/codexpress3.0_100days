Steve’s inventory row is a list of item IDs. If the same item appears twice too close to each other (distance between their indices ≤ k), that’s a glitch.

Goal: Check if any duplicate item appears within k distance.

Output: Print "GLITCH FOUND" if yes, otherwise "SAFE".

Input and output
Input:

First line: n (size of inventory)

Second line: n space-separated integers (item IDs)

Third line: k (maximum allowed distance)

Output:

One string: "GLITCH FOUND" or "SAFE"

Constraints
n: up to typical coding challenge limits (large arrays are fine)

Item IDs: integers (can be large or negative; treat as keys)

k: non-negative integer

Approach
Idea: Track the last index where each item was seen using a hash map.

Process:

For each item, if seen before, compute distance from its last occurrence.

If distance ≤ k, glitch found → print and terminate.

Otherwise, update last seen index and continue.

Why a hash map: O(1) average lookup, single-pass O(n) solution.

C++ solution
cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<long long> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];
    long long k;
    cin >> k;

    unordered_map<long long, int> lastSeen; // item -> last index

    for (int i = 0; i < n; i++) {
        auto it = lastSeen.find(arr[i]);
        if (it != lastSeen.end()) {
            if (i - it->second <= k) {
                cout << "GLITCH FOUND\n";
                return 0; // terminate program immediately after finding glitch
            }
        }
        lastSeen[arr[i]] = i;
    }

    cout << "SAFE\n";
    return 0;
}
Dry run step by step
Sample 1
Input:

n = 4

arr = [1, 2, 3, 1]

k = 3

Steps:

i=0, item=1: lastSeen empty → lastSeen[1] = 0

i=1, item=2: lastSeen[2] = 1

i=2, item=3: lastSeen[3] = 2

i=3, item=1: seen before at index 0 → distance = 3

Check: 3 ≤ k(3) → glitch found → print "GLITCH FOUND" and stop

Output: GLITCH FOUND

Sample 2
Input:

n = 6

arr = [1, 2, 3, 1, 2, 3]

k = 2

Steps:

i=0, item=1: lastSeen[1] = 0

i=1, item=2: lastSeen[2] = 1

i=2, item=3: lastSeen[3] = 2

i=3, item=1: seen at 0 → distance = 3 > 2 → update lastSeen[1] = 3

i=4, item=2: seen at 1 → distance = 3 > 2 → update lastSeen[2] = 4

i=5, item=3: seen at 2 → distance = 3 > 2 → update lastSeen[3] = 5

End without finding any distance ≤ 2

Output: SAFE

Complexity
Time: O(n) single pass

Space: O(n) in worst case for hash map

Notes and alternatives
Return vs break: Use return 0; to end the program immediately after printing "GLITCH FOUND". A break would only exit the loop, and could lead to printing "SAFE" later by mistake.

Robustness: Use long long for IDs and k to handle large values safely.
