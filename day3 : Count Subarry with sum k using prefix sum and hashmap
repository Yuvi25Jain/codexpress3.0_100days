Concept of Prefix sum pattern

  /*Prefix sum : {1,2,3} o/p = {1,3,6}*/
void prefixSum(int a[], int n ){
    int ps[n];
    ps[0] = a[0];
    for(int i = 1 ; i<n ; i++){
        ps[i] = ps[i-1] + a[i];
    }
    
    for(int i = 0 ; i<n ; i++){
        cout<<ps[i]<<" ";
    }
   
}

Question:

Sum = k using prefix sum + hashmap 


STL two option

1. ordered map i.e #include<map> internal implementation is red black
tree , take o(logn) in sorted fashion

std::map<int, int> mp;
mp[5] = 10;        // insert key=5, value=10
std::cout << mp[5]; // prints 10

2. unordered_map : not in sorted order , useful for fast lookups , internal implementation
of hash table , o(1)
std::unordered_map<int, int> ump;
ump[5] = 10;
std::cout << ump[5]; //print 10

 int ps = 0, cnt = 0;
unordered_map<int,int> mp = {{0,1}};

for(int i = 0; i < N; i++){
    ps += a[i];

    if(mp.find(ps - K) != mp.end()){
        cnt += mp[ps - K];
    }

    // Always update frequency of current prefix sum
    mp[ps]++;
}

same mine code : issue was not giving right answer in one testcase , due to loop issue

      // int ps = 0 ,  cnt = 0 ;
    // unordered_map<int,int> mp = {{0,1}}; 
    
    // // travserse house / array

    // for(int i = 0; i< N ; i++){
    //     ps = ps + a[i];
        
    //     // if ps-k exist , if it then increase its count else add its entry
    // //here we want to check if (ps-k) exist as key or not
    //     if(mp.find(ps - K) != mp.end()) {
    // cnt += mp[ps - K];   // add frequency of that prefix sum
    // }
    
    // else{
    //     mp[ps] ++ ; 
    // }
        
    // }

  ---------'

platform code:

int sum_subarray(vector<int> &a , int N , int K ){
    N = a.size();
     int ps = 0, cnt = 0;
unordered_map<int,int> mp = {{0,1}};

for(int i = 0; i < N; i++){
    ps += a[i];

    if(mp.find(ps - K) != mp.end()){
        cnt += mp[ps - K];
    }

    // Always update frequency of current prefix sum
    mp[ps]++;
}

    return cnt;
}
----------------------

  int main() {
    int N, K;
    cin >> N >> K;              // read N and K
    vector<int> a(N);
    for(int i = 0; i < N; i++) {
        cin >> a[i];            // read threat levels
    }

    cout << sum_subarray(a, N, K) << "\n";
    
    return 0;
}
