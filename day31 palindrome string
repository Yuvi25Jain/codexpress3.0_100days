



ğŸ“Œ Problem Statement
In a Minecraft world, players discover an ancient Redstone Mirror hidden beneath the village plaza.
The mirror reacts only to perfectly symmetrical messages (palindromes).

A message is valid if:

All uppercase letters are converted to lowercase.

All nonâ€‘alphanumeric characters are removed.

The processed string reads the same forwards and backwards.

ğŸ‘‰ If valid, the mirror lights up (true). Otherwise, it remains dark (false).

ğŸ“¥ Input Format
First line: T (number of test cases).

Next T lines: each contains a string s (the phrase to check).

ğŸ“¤ Output Format
For each test case, output "true" if the phrase is a palindrome, otherwise "false".

ğŸ”’ Constraints
1 â‰¤ s.length â‰¤ 2 Ã— 10^5

s consists only of printable ASCII characters.

ğŸ§© Sample Input 0
Code
1
A man, a plan, a canal: Panama
ğŸ“Œ Sample Output 0
Code
true
ğŸš€ Approaches
1. Twoâ€‘Pointer Approach
Idea: Use two indices (l and r) starting from both ends.

Skip nonâ€‘alphanumeric characters.

Compare lowercase characters.

If mismatch â†’ not palindrome.

If all match â†’ palindrome.

Usefulness:

Efficient: O(N) time, O(1) extra space.

Best for large strings.

Directly checks without building new strings.

2. Stack Approach
Idea: Push first half of characters onto a stack.

Pop and compare with second half.

Skip nonâ€‘alphanumeric and ignore case.

Usefulness:

Intuitive for beginners (mirrors the definition of palindrome).

Good for educational purposes.

Less spaceâ€‘efficient (O(N) stack).

ğŸ§‘â€ğŸ’» C++ Solution â€” Twoâ€‘Pointer (Optimized)
cpp
#include <bits/stdc++.h>
using namespace std;

bool isPalindrome(const string &s) {
    int l = 0, r = (int)s.size() - 1;
    while (l < r) {
        while (l < r && !isalnum(s[l])) l++;
        while (l < r && !isalnum(s[r])) r--;
        if (tolower(s[l]) != tolower(s[r])) return false;
        l++;
        r--;
    }
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;
    cin.ignore();
    while (T--) {
        string s;
        getline(cin, s);
        cout << (isPalindrome(s) ? "true" : "false") << "\n";
    }
    return 0;
}
ğŸ§‘â€ğŸ’» C++ Solution â€” Stack Approach
cpp
#include <bits/stdc++.h>
using namespace std;

bool isPalindromeStack(const string &s) {
    string filtered;
    for (char c : s) {
        if (isalnum(c)) filtered.push_back(tolower(c));
    }
    int n = filtered.size();
    stack<char> st;
    for (int i = 0; i < n/2; i++) st.push(filtered[i]);
    int start = (n % 2 == 0) ? n/2 : n/2 + 1;
    for (int i = start; i < n; i++) {
        if (st.top() != filtered[i]) return false;
        st.pop();
    }
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;
    cin.ignore();
    while (T--) {
        string s;
        getline(cin, s);
        cout << (isPalindromeStack(s) ? "true" : "false") << "\n";
    }
    return 0;
}
âš¡ Complexity
Twoâ€‘Pointer:

Time: O(N)

Space: O(1)

Stack:

Time: O(N)

Space: O(N)

ğŸ§© Dry Run Example
Input:
Code
1
race a car
Steps:

Filtered string: raceacar

Twoâ€‘Pointer: mismatch at c vs a â†’ false

Stack: mismatch when popping â†’ false

ğŸ‘‰ Output: false

ğŸ¯ Key Takeaway
Twoâ€‘Pointer: Best for performance, minimal memory.

Stack: Easier to understand conceptually, but less efficient.

Both approaches are valid; choice depends on context (efficiency vs clarity).
