ğŸ” Problem Restatement
You have an array nums of nonâ€‘negative integers.

In one operation:

Choose x â‰¤ smallest nonâ€‘zero element.

Subtract x from every positive element.

Goal: minimum operations to make all elements = 0.

ğŸ§  Key Insight
Every operation corresponds to moving down to the next distinct positive height.

Because you always subtract the smallest nonâ€‘zero value, you â€œjumpâ€ from one distinct level to the next.

So the number of operations = count of distinct positive values in the array.

ğŸ§© Example Walkthrough
Input: [1, 5, 0, 3, 5]
Distinct positive values = {1,3,5}.

Turn 1: subtract 1 â†’ [0,4,0,2,4].

Turn 2: subtract 2 â†’ [0,2,0,0,2].

Turn 3: subtract 2 â†’ [0,0,0,0,0].

Done in 3 turns. âœ…

Input: [0]
Distinct positive values = {}.

Already zero â†’ 0 turns. âœ…



  int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        vector<int> nums(n);
        for (int i = 0; i < n; i++) cin >> nums[i];

        unordered_set<int> distinct;
        for (int h : nums) {
            if (h > 0) distinct.insert(h);
        }

        cout << distinct.size() << "\n";
    }
    return 0;
}
âœ… Why This Works
Each distinct positive value requires one operation.

Using a set ensures uniqueness.

Efficient: O(N) per test case.
