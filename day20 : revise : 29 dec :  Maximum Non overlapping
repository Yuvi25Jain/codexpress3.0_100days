ğŸ§© Problem â€” Maximum Nonâ€‘Overlapping Piglin Trades
ğŸ“Œ Problem Statement
You are a Speedrunner attempting to complete as many trades as possible with Piglins.
Each trade offer is available only during a specific time interval [Start, End].

Rules:

You can only handle one trade at a time.

Once you start a trade, you must finish it before starting another.

Goal: calculate the maximum number of nonâ€‘overlapping trades you can complete.

ğŸ“¥ Input Format
Line 1: Integer N (number of trades).

Next N lines: Two integers Start and End for each trade.

ğŸ“¤ Output Format
A single integer: maximum number of nonâ€‘overlapping trades.

ğŸ”’ Constraints
1 <= N <= 10^5

0 <= Start < End <= 10^9

ğŸ§© Sample Input 0
Code
3
1 3
2 4
3 5
ğŸ“Œ Sample Output 0
Code
2
ğŸ“ Explanation 0
Pick [1,3] and [3,5].

[2,4] overlaps with both, so skip it.

Maximum trades = 2.

ğŸ§© Sample Input 1
Code
4
1 2
2 3
3 4
4 5
ğŸ“Œ Sample Output 1
Code
4
ğŸ“ Explanation 1
All trades can be done since each ends exactly when the next begins.

Maximum trades = 4.

ğŸš€ Solution Approach
This is the Activity Selection Problem:

Sort all trades by their end time.

Pick the first trade.

For each next trade:

If its start â‰¥ last chosen end, select it.

Otherwise, skip it.

Count how many trades you selected.

ğŸ‘‰ Greedy choice: picking the earliest finishing trade leaves maximum room for future trades.

ğŸ§‘â€ğŸ’» C++ Implementation
cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;
    vector<pair<long long, long long>> trades(N);

    for (int i = 0; i < N; i++) {
        cin >> trades[i].first >> trades[i].second; // start, end
    }

    // Sort by end time
    sort(trades.begin(), trades.end(), [](auto &a, auto &b) {
        return a.second < b.second;
    });

    int count = 0;
    long long lastEnd = -1;

    for (auto &t : trades) {
        if (t.first >= lastEnd) {
            count++;
            lastEnd = t.second;
        }
    }

    cout << count << "\n";
    return 0;
}
âš¡ Complexity
Sorting: O(N log N)

Selection: O(N)

Total: O(N log N)

Works efficiently for N = 10^5.
