ğŸ“Œ Problem Statement
Steve is building a minecart system to transport villagers.
The world is divided into Chunks, and the server has a strict rule:
A railway section is only stable if the total length of its rails is perfectly divisible by the Chunk Stability Factor (K).

You are given an array representing the lengths of individual rail segments placed in a row.
Find the longest continuous subarray of rails such that their combined length is divisible by K.
If no such segment exists, output 0.

ğŸ“¥ Input Format
First line: Two integers N (number of rail segments) and K (Chunk Stability Factor).

Second line: N space-separated integers representing the length of each rail segment.

ğŸ“¤ Output Format
One integer: maximum number of segments in a valid stable subarray.

ğŸ”’ Constraints
1 <= N <= 10^5

1 <= K <= 10^9

1 <= Segment[i] <= 10^9

ğŸ§© Sample Input 0
Code
4 5
5 10 15 20
ğŸ“Œ Sample Output 0
Code
4
ğŸ“ Explanation
Entire array sum = 50.

50 % 5 = 0 â†’ divisible.

So longest stable subarray = 4.

ğŸš€ Approach
Compute prefix sums while traversing the array.

Take each prefix sum modulo K.

If two prefix sums have the same remainder, the subarray between them is divisible by K.

Use a hash map to store the first index of each remainder.

Track the maximum distance between equal remainders.

Answer = longest subarray length found.

ğŸ‘‰ Pattern used: Prefix Sum + Hash Map (not sliding window).

ğŸ§‘â€ğŸ’» C++ Solution
cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    long long k;
    cin >> n >> k;
    vector<long long> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];

    unordered_map<long long,int> firstSeen; // remainder -> first index
    long long prefix = 0;
    int ans = 0;

    for (int i = 0; i < n; i++) {
        prefix += arr[i];
        long long rem = prefix % k;
        if (rem < 0) rem += k; // handle negatives

        if (rem == 0) {
            ans = max(ans, i+1); // whole prefix divisible
        }
        if (firstSeen.count(rem)) {
            ans = max(ans, i - firstSeen[rem]);
        } else {
            firstSeen[rem] = i;
        }
    }

    cout << ans << "\n";
    return 0;
}
âš¡ Complexity
Time: O(N)

Space: O(N) (hash map for remainders)

ğŸ§© Dry Run Example
Input:
Code
6 7
2 3 1 6 4 5
Prefix sums: [2, 5, 6, 12, 16, 21]

Modulo 7: [2, 5, 6, 5, 2, 0]

Step by step:

i=0 â†’ rem=2 â†’ store firstSeen[2]=0

i=1 â†’ rem=5 â†’ store firstSeen[5]=1

i=2 â†’ rem=6 â†’ store firstSeen[6]=2

i=3 â†’ rem=5 â†’ seen before at index 1 â†’ length = 3âˆ’1=2

i=4 â†’ rem=2 â†’ seen before at index 0 â†’ length = 4âˆ’0=4

i=5 â†’ rem=0 â†’ whole prefix length = 6

ğŸ‘‰ Answer = 6 (entire array divisible by 7).

ğŸ¯ Key Takeaway
Brute force = O(NÂ²).

Efficient = O(N) using Prefix Sum + Hash Map.

Sliding window doesnâ€™t apply here because divisibility is not monotonic.
