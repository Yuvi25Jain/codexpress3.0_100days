Problem : 
we have array nums of values , 
strategy : pick smallest unmarked block ( leftmost index) , add its values to score , mark the block and its immediate neighbors . repeat until all block are marked
  output  : final score


Observation : pick minimum unmarked value means min heap (priority queue) , tie breaking store(value , index) in heap , once blocked is mined mark it and its neighbors use a vector<bool> to track destroyed blokced


  Complexcity : o(nlongn)


ðŸ§© Dry Run
Example: [2,1,3,4,5,2]
Heap = [(1,1), (2,0), (2,5), (3,2), (4,3), (5,4)]
Pick (1,1) â†’ score=1, mark indices 0,1,2. [cancels /destroy (2,0) and (3,2)]
Next valid min = (2,5) â†’ score=3, mark indices 4,5. [ remain 4 , 5 , 2  their min is 2 , so mark (2,5) and destroy (5,4)]
Next valid min = (4,3) â†’ score=7, mark index 3. [ remain is only 4 , so destroy it as well]
Done â†’ final score=7 âœ….


int main() {
  int T; cin >> T;
  while (T--) { 
    int N;
    cin >> N;
    vector<int> nums(N); 
    for (int i = 0; i < N; i++) 
      cin >> nums[i]; 
    // Min-heap with (value, index) : in cpp by deault max heap using priority_queue but to make it min heap use greater<pair<int, int> comparator 
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq; 
    for (int i = 0; i < N; i++) { 
      pq.push({nums[i], i});
    } 
    vector<bool> marked(N, false); 
    long long score = 0; 
    int markedCount = 0; 
    while (markedCount < N) { 
      auto [val, idx] = pq.top(); 
      pq.pop(); 
      if (marked[idx]) continue; // already destroyed 
      // Mine this block 
      score += val; 
      // Mark idx and neighbors 
      for (int j : {idx-1, idx, idx+1}) { 
        if (j >= 0 && j < N && !marked[j]) { 
          marked[j] = true;
          markedCount++; 
        } 
      } 
    } 
    cout << score << "\n"; 
  } 
  return 0; 
}
