Problem Restatement
- Maze = array of chambers.  
- Start at index 0, goal = index N-1.  
- Allowed moves:
  1. Step forward (i+1).  
  2. Step backward (i-1).  
  3. Teleport to any other chamber with the same magical number (arr[i] == arr[j]).  
- Find minimum steps to reach the last chamber.

---

2. Pattern Connection
- This is exactly LeetCode 1345 â€“ Jump Game IV.  
- Both problems:  
  - Array of numbers.  
  - Allowed moves: Â±1 step or teleport to same value.  
  - Goal: minimum steps to reach end.  
- Solution: Breadthâ€‘First Search (BFS).

---

3. Optimized Approach
- Treat each chamber as a node in a graph.  
- Edges = possible moves (Â±1 or teleport).  
- Use BFS starting from index 0.  
- Track visited indices to avoid cycles.  
- Optimization: Once youâ€™ve used teleportation for a value, clear its list to avoid redundant revisits.

---

4. C++ Implementation
`cpp

include <bits/stdc++.h>
using namespace std;

int minSteps(vector<int>& arr) {
    int n = arr.size();
    unordered_map<int, vector<int>> graph;
    for (int i = 0; i < n; i++) {
        graph[arr[i]].push_back(i);
    }

    vector<bool> visited(n, false);
    queue<pair<int,int>> q; // {index, steps}
    q.push({0, 0});
    visited[0] = true;

    while (!q.empty()) {
        auto [i, steps] = q.front(); q.pop();
        if (i == n-1) return steps;

        // Move forward
        if (i+1 < n && !visited[i+1]) {
            visited[i+1] = true;
            q.push({i+1, steps+1});
        }
        // Move backward
        if (i-1 >= 0 && !visited[i-1]) {
            visited[i-1] = true;
            q.push({i-1, steps+1});
        }
        // Teleport
        for (int j : graph[arr[i]]) {
            if (!visited[j]) {
                visited[j] = true;
                q.push({j, steps+1});
            }
        }
        graph[arr[i]].clear(); // optimization: avoid reusing same value teleports
    }
    return -1; // should never happen
}

int main() {
    ios::syncwithstdio(false);
    cin.tie(nullptr);

    int T; cin >> T;
    while (T--) {
        int N; cin >> N;
        vector<int> arr(N);
        for (int i = 0; i < N; i++) cin >> arr[i];
        cout << minSteps(arr) << "\n";
    }
    return 0;
}
`

---

5. Dry Run (Sample Input)
`
arr = [100, -23, -23, 404, 100, 23, 23, 23, 3, 404]
`
- Start at 0 (100).  
- Teleport to 4 (100). Steps = 1.  
- Move back to 3 (404). Steps = 2.  
- Teleport to 9 (404). Steps = 3.  
- Goal reached. âœ…

---

6. Complexity
- Time: \(O(N)\) because each index is visited once, and teleport lists are cleared after use.  
- Space: \(O(N)\) for visited + graph.

---

ðŸŽ¯ Revision Hook
When you see:
- Array + teleport to same values + Â±1 moves â†’ BFS.  
- Build map of value â†’ indices.  
- BFS from 0 to N-1.  
- Clear teleport list after use to avoid reprocessing.  

ðŸ‘‰ Memory trick:  
â€œItâ€™s Jump Game IV in disguise â€” BFS with teleport optimization.â€

---