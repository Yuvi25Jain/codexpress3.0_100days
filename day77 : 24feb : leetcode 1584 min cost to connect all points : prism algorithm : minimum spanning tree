ğŸ§  Problem Restatement
You have n crime scenes, each with coordinates (xi, yi).
Effort to connect two scenes = Manhattan distance = 
âˆ£ğ‘¥ğ‘–âˆ’ğ‘¥ğ‘—|+âˆ£ğ‘¦ğ‘–âˆ’ğ‘¦ğ‘—âˆ£
You need to connect all scenes with minimum total effort so that every scene is reachable.
This is exactly the MST problem: connect all nodes with minimum edge cost.

-------------------------------------------------------------------------------------------------------------

ğŸŒ³ DSA Pattern
  Graph: Nodes = crime scenes, Edges = Manhattan distances.
Pattern: Minimum Spanning Tree (MST).
Algorithms:
Primâ€™s Algorithm (efficient for dense graphs, avoids building all edges explicitly).
Kruskalâ€™s Algorithm (requires sorting all edges, but here edges = 
ğ‘‚(ğ‘›2), too heavy for n=1000).

ğŸ‘‰ Best choice: Primâ€™s Algorithm with a priority queue.

---------------------------------------------------------------------------------------------------------
ğŸš€ Approach (Primâ€™s Algorithm)
Start from any node.
Use a minâ€‘heap (priority queue) to pick the smallest edge connecting to an unvisited node.
Add that node to the MST.
Repeat until all nodes are connected.
Sum of chosen edges = minimum effort.

------------------------------------------------------------------------------------------------------------
Code 


#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        int n = points.size();
        vector<bool> inMST(n, false);
        int edgesUsed = 0;
        int cost = 0;

        // Min-heap storing {distance, node}
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
        pq.push({0, 0}); // start from node 0

        while (edgesUsed < n) {
            auto [dist, u] = pq.top(); pq.pop();
            if (inMST[u]) continue; // skip if already in MST

            inMST[u] = true;
            cost += dist;
            edgesUsed++;

            // push all edges from u to other nodes
            for (int v = 0; v < n; v++) {
                if (!inMST[v]) {
                    int d = abs(points[u][0] - points[v][0]) + abs(points[u][1] - points[v][1]);
                    pq.push({d, v});
                }
            }
        }
        return cost;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T; cin >> T;
    while (T--) {
        int n; cin >> n;
        vector<vector<int>> points(n, vector<int>(2));
        for (int i = 0; i < n; i++) {
            cin >> points[i][0] >> points[i][1];
        }
        Solution sol;
        cout << sol.minCostConnectPoints(points) << "\n";
    }
    return 0;
}

------------------------------------------------------------------------------------------------------------

ğŸ” Dry Run (Sample Input)
points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Start at (0,0).
Connect (2,2) â†’ cost 4.
Connect (5,2) â†’ cost 3.
Connect (7,0) â†’ cost 4.
Connect (3,10) â†’ cost 9.

Total = 20 âœ…

------------------------------------------------------------------------------------------------------------

ğŸ“Œ Complexity
Time: 
ğ‘‚(ğ‘›2logğ‘›) because for each node we may push up to ğ‘› edges into the heap.

Space: 
ğ‘‚(ğ‘›2) in worst case for heap storage, but practically 
ğ‘‚(ğ‘›) for visited + heap.
Works fine for ğ‘›â‰¤1000

-------------------------------------------------------------------------------------------------------------
ğŸ¯ Key Takeaway
This problem is a Minimum Spanning Tree with Manhattan distance.
Use Primâ€™s Algorithm with a priority queue.
Kruskalâ€™s is possible but less efficient here.
This is exactly LeetCode 1584: Min Cost to Connect All Points.

