Problem Meaning
- City has N locations.  
- Ronaldoâ€™s house = S, gym = G, training ground = D.  
- Travel times between locations are given in an N Ã— N matrix T.  
- Ronaldoâ€™s routine: always goes House â†’ Gym â†’ Training Ground.  
- We need to compute:
  1. Time taken via gym = dist(S,G) + dist(G,D).  
  2. Time saved if direct = (dist(S,G) + dist(G,D)) - dist(S,D).

---

2. Key Insight
- The matrix T gives direct travel times, but Ronaldo can take indirect routes too.  
- So we need shortest paths between all pairs.  
- Best algorithm: Floydâ€“Warshall (since N â‰¤ 250).  
  - Precompute shortest paths between all pairs.  
  - Then answer each scenario in O(1).

---

3. Stepâ€‘byâ€‘Step Code Logic

Part A: Input
`cpp
int N; cin >> N;
vector<vector<int>> T(N, vector<int>(N));
for (int i = 0; i < N; i++)
    for (int j = 0; j < N; j++)
        cin >> T[i][j];
`
- Read number of locations.  
- Read travel time matrix.

---

Part B: Floydâ€“Warshall
`cpp
for (int k = 0; k < N; k++)
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            T[i][j] = min(T[i][j], T[i][k] + T[k][j]);
`
- Compute shortest paths between all pairs.  
- After this, T[i][j] = minimum time to go from i to j.

---

Part C: Answer Scenarios
`cpp
int M; cin >> M;
while (M--) {
    int S, G, D; cin >> S >> G >> D;
    int viaGym = T[S][G] + T[G][D];
    int direct = T[S][D];
    int saved = viaGym - direct;
    cout << viaGym << " " << saved << "\n";
}
`
- For each scenario:
  - Compute time via gym.  
  - Compute direct time.  
  - Compute saved time.  
  - Print both.

---

4. Dry Run (Sample Input 0)
`
N=4
Matrix:
0 2 1 3
1 0 4 5
3 1 0 3
1 1 1 0
Scenarios:
0 2 1
0 2 2
3 1 2
3 0 1
`

- After Floydâ€“Warshall, shortest paths are updated.  
- Scenario 1: S=0, G=2, D=1  
  - viaGym = T[0][2] + T[2][1] = 1 + 1 = 2  
  - direct = T[0][1] = 2  
  - saved = 0  
  - Output: 2 0 âœ…

---

5. Revision Hook
When you see this type of question:
- Step 1: â€œLocations + travel times â†’ Graph.â€  
- Step 2: â€œNeed shortest paths between all pairs â†’ Floydâ€“Warshall.â€  
- Step 3: â€œRoutine = Sâ†’Gâ†’D, Direct = Sâ†’D.â€  
- Step 4: â€œAnswer = viaGym, viaGym â€“ direct.â€  

ðŸ‘‰ Quick brute force thought:  
- If only one scenario, run Dijkstra from S.  
- But since M can be up to 10,000, precompute all pairs shortest paths once (Floydâ€“Warshall).

---

ðŸŽ¯ Memory Trick
Think of it as:  
â€œRonaldo always stops at gym â†’ compute shortest paths â†’ compare gym route vs direct route â†’ print time and saved time.â€

---


What is Floydâ€“Warshall?
- Itâ€™s a shortest path algorithm.  
- Specifically, it finds the minimum distance between every pair of nodes in a weighted graph.  
- Works even if the graph has many edges, as long as there are no negative cycles.  
- Think of it as a â€œpathâ€‘improvement theoremâ€:  
  - If going from i â†’ j directly is longer than going i â†’ k â†’ j, then update the path via k.

---

2. The Core Idea (Min Path Finding Theorem)
Yes, youâ€™re right â€” itâ€™s essentially a min path finding theorem:

\[
\text{dist}[i][j] = \min(\text{dist}[i][j], \text{dist}[i][k] + \text{dist}[k][j])
\]

- For every possible intermediate node k, check if passing through k gives a shorter route between i and j.  
- Keep updating until all shortest paths are found.

---

3. Algorithm Steps
1. Start with the given adjacency matrix (direct travel times).  
2. For each node k (as intermediate):  
   - For each pair (i, j):  
     - Update dist[i][j] if going through k is shorter.  
3. After N iterations, dist[i][j] holds the shortest path between every pair.

---

4. Example (Mini City)
Matrix:
`
0 5 9
âˆž 0 2
âˆž âˆž 0
`
- Direct path 0â†’2 = 9.  
- But 0â†’1â†’2 = 5 + 2 = 7.  
- Floydâ€“Warshall updates dist[0][2] = 7.  
- Thatâ€™s the â€œmin path finding theoremâ€ in action.

---

5. Complexity
- Time: \(O(N^3)\) (three nested loops).  
- Space: \(O(N^2)\) (matrix).  
- Works fine for N â‰¤ 250 (like Ronaldoâ€™s problem).

---

6. Revision Hook
When you see â€œall pairs shortest pathâ€:
- Step 1: Graph given as matrix.  
- Step 2: Need shortest path between every pair.  
- Step 3: Think Floydâ€“Warshall: triple loop, update via intermediate.  
- Step 4: Formula: dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]).

ðŸ‘‰ Quick memory trick:  
â€œTry every middleman (k). If he makes the deal cheaper, update the cost.â€


#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N; 
    cin >> N;
    vector<vector<int>> dist(N, vector<int>(N));

    // Input travel time matrix
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cin >> dist[i][j];
        }
    }

    // Floydâ€“Warshall: all pairs shortest paths
    for (int k = 0; k < N; k++) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }

    int M; 
    cin >> M;
    while (M--) {
        int S, G, D; 
        cin >> S >> G >> D;

        int viaGym = dist[S][G] + dist[G][D];  // routine path
        int direct = dist[S][D];               // direct path
        int saved = viaGym - direct;           // time saved

        cout << viaGym << " " << saved << "\n";
    }

    return 0;
}


_--------



LeetCode 1334 â€“ Find the City With the Smallest Number of Neighbors at a Threshold Distance