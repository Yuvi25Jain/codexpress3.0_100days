ğŸ“Œ Problem Statement
In the vast world of Minecraft, a player explores a long stretch of land made of blocks.

Each block contains a certain number of resources (diamonds, emeralds, etc.).

A resourceâ€‘rich zone is defined as the longest contiguous sequence of blocks such that the total resources â‰¥ threshold T.

If no such region exists, return -1.

ğŸ‘‰ Task: Find the length of the largest contiguous subarray whose sum â‰¥ T.

ğŸ“¥ Input Format
First line: integer t (number of test cases).

For each test case:

First line: integer n (number of blocks).

Second line: array blocks of size n.

Third line: integer T (minimum resources required).

ğŸ“¤ Output Format
For each test case, output a single integer:

The length of the largest contiguous block region with sum â‰¥ T.

Or -1 if no such region exists.

ğŸ”’ Constraints
1 â‰¤ t â‰¤ 100

1 â‰¤ n â‰¤ 10^5

0 â‰¤ blocks[i] â‰¤ 10^9

1 â‰¤ T â‰¤ 10^18

Total blocks across all test cases â‰¤ 10^6.

ğŸ§© Sample Input
Code
1
5
1 1 1 1 1
10
ğŸ“Œ Sample Output
Code
-1
ğŸ“ Explanation
Total resources in all blocks = 5 < 10.

No valid subarray exists â†’ output -1.

ğŸš€ Approach
We use a sliding window:

Expand window by moving right pointer and adding resources.

While sum â‰¥ T, update maximum length.

Shrink window from left to explore longer possible zones.

If no valid zone found, return -1.

ğŸ‘‰ Runs in O(n) per test case.

ğŸ§‘â€ğŸ’» C++ Solution
cpp
#include <bits/stdc++.h>
using namespace std;

int largestResourceRichZone(vector<int>& blocks, long long T) {
    long long sum = 0;
    int maxLen = -1;
    int left = 0;

    for (int right = 0; right < blocks.size(); right++) {
        sum += blocks[right];
        while (left <= right && sum >= T) {
            maxLen = max(maxLen, right - left + 1);
            sum -= blocks[left++];
        }
    }
    return maxLen;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> blocks(n);
        for (int i = 0; i < n; i++) cin >> blocks[i];
        long long T;
        cin >> T;

        cout << largestResourceRichZone(blocks, T) << "\n";
    }
    return 0;
}
âš¡ Complexity
Time: O(n) per test case.

Space: O(1) extra (besides input array).

ğŸ§© Dry Run Example
Input:
Code
1
6
2 3 1 2 4 3
7
Steps:

Window [2,3,1,2] â†’ sum=8 â‰¥ 7 â†’ length=4.

Window [3,1,2,4] â†’ sum=10 â‰¥ 7 â†’ length=4.

Window [1,2,4,3] â†’ sum=10 â‰¥ 7 â†’ length=4.
ğŸ‘‰ Output: 4.

ğŸ¯ Key Takeaway
This is a sliding window problem.

Efficiently finds the longest subarray with sum â‰¥ T.

Returns -1 if no valid region exists
