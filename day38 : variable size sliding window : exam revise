ğŸ§© DSA Pattern: Sliding Window (Variable Size)
Day 38 â€” Emerald Cave Trap
ğŸ“Œ Problem Statement
Deep underground in a Minecraft cave, there are n connected tunnels, each containing emeralds.

You can mine emeralds from a continuous sequence of tunnels.

Rule: If two tunnels in your chosen sequence contain the same emerald count, the Redstone trap activates and you lose everything.

Goal: Choose exactly one continuous subarray where all emerald counts are unique, and maximize the sum of emeralds collected.

ğŸ“¥ Input Format
First line: integer T (number of test cases).

For each test case:

First line: integer n (number of tunnels).

Second line: n spaceâ€‘separated integers, where tunnel[i] = emeralds in the iâ€‘th tunnel.

ğŸ“¤ Output Format
For each test case, print a single integer â€” the maximum emeralds you can safely mine.

ğŸ”’ Constraints
1 â‰¤ T â‰¤ 1000

1 â‰¤ n â‰¤ 10^5

1 â‰¤ tunnel[i] â‰¤ 10^4

Total input size across test cases â‰¤ 10^6.

ğŸ§© Sample Input
Code
1
5
4 2 4 5 6
ğŸ“Œ Sample Output
Code
17
ğŸ“ Explanation
Optimal subarray: [2,4,5,6] â†’ sum = 17.

[4,2,4,5,6] invalid because 4 repeats.

ğŸš€ Approach (Sliding Window + HashSet)
Use two pointers (left, right) to maintain a window of unique emerald counts.

Track current sum of emeralds in the window.

If a duplicate is found, shrink from the left until unique again.

Update maximum sum at each step.

ğŸ‘‰ Runs in O(n) per test case.

ğŸ§‘â€ğŸ’» C++ Solution
cpp
#include <bits/stdc++.h>
using namespace std;

long long maxUniqueSum(vector<int>& tunnels) {
    unordered_set<int> seen;
    long long maxSum = 0, currSum = 0;
    int left = 0;

    for (int right = 0; right < tunnels.size(); right++) {
        while (seen.count(tunnels[right])) {
            seen.erase(tunnels[left]);
            currSum -= tunnels[left];
            left++;
        }
        seen.insert(tunnels[right]);
        currSum += tunnels[right];
        maxSum = max(maxSum, currSum);
    }
    return maxSum;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        vector<int> tunnels(n);
        for (int i = 0; i < n; i++) cin >> tunnels[i];

        cout << maxUniqueSum(tunnels) << "\n";
    }
    return 0;
}
âš¡ Complexity
Time: O(n) per test case.

Space: O(n) for the set.

ğŸ§© Dry Run Example
Input:
Code
1
9
5 2 1 2 5 2 1 2 5
Steps:

Window expands: [5,2,1] â†’ sum=8 â†’ max=8

Next element 2 is duplicate â†’ shrink window.

Later window [1,2,5] â†’ sum=8 â†’ max=8.

ğŸ‘‰ Output: 8.

ğŸ¯ Key Takeaway
This is a variableâ€‘size sliding window problem.

Maintain uniqueness with a set.

Track maximum sum dynamically.
